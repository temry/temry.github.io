<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>【MSPM0G3507】学习笔记(1)：搭建基于CCS+UniFlash的开发环境 | Gridea</title>
<link rel="shortcut icon" href="https://temry.github.io/favicon.ico?v=1764314151364">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://temry.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="【MSPM0G3507】学习笔记(1)：搭建基于CCS+UniFlash的开发环境 | Gridea - Atom Feed" href="https://temry.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="目录
前言
一、开发环境选择
二、开发板选择
三、MSPM0_SDK下载及配置
	1、MSPM0_SDK简介
	2、软件获取
	3、软件安装
	4、软件配置
四、CCS下载及配置
	1、CCS简介
	2、软件获取
	3、软件安装
	4、软件..." />
    <meta name="keywords" content="单片机" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://temry.github.io">
  <img class="avatar" src="https://temry.github.io/images/avatar.png?v=1764314151364" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              【MSPM0G3507】学习笔记(1)：搭建基于CCS+UniFlash的开发环境
            </h2>
            <div class="post-info">
              <span>
                2025-11-28
              </span>
              <span>
                14 min read
              </span>
              
                <a href="https://temry.github.io/tag/YWCxu6iv8V/" class="post-tag">
                  # 单片机
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p><strong>目录</strong></p>
<p><a href="#%E5%89%8D%E8%A8%80">前言</a><br>
<a href="#%E4%B8%80%E3%80%81%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%80%89%E6%8B%A9">一、开发环境选择</a><br>
<a href="#%E4%BA%8C%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E9%80%89%E6%8B%A9">二、开发板选择</a><br>
<a href="#%E4%B8%89%E3%80%81MSPM0_SDK%E4%B8%8B%E8%BD%BD%E5%8F%8A%E9%85%8D%E7%BD%AE">三、MSPM0_SDK下载及配置</a><br>
<a href="#1%E3%80%81MSPM0_SDK%E7%AE%80%E4%BB%8B">	1、MSPM0_SDK简介</a><br>
<a href="#2%E3%80%81%E8%BD%AF%E4%BB%B6%E8%8E%B7%E5%8F%96">	2、软件获取</a><br>
<a href="#3%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">	3、软件安装</a><br>
<a href="#4%E3%80%81%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE">	4、软件配置</a><br>
<a href="#%E5%9B%9B%E3%80%81CCS%E4%B8%8B%E8%BD%BD%E5%8F%8A%E9%85%8D%E7%BD%AE">四、CCS下载及配置</a><br>
<a href="#1%E3%80%81CCS%E7%AE%80%E4%BB%8B">	1、CCS简介</a><br>
<a href="#2%E3%80%81%E8%BD%AF%E4%BB%B6%E8%8E%B7%E5%8F%96">	2、软件获取</a><br>
<a href="#3%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">	3、软件安装</a><br>
<a href="#4%E3%80%81%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE">	4、软件配置</a><br>
<a href="#%E4%BA%94%E3%80%81UniFlash%E4%B8%8B%E8%BD%BD%E5%8F%8A%E9%85%8D%E7%BD%AE">五、UniFlash下载及配置</a><br>
<a href="#1%E3%80%81UniFlash%E7%AE%80%E4%BB%8B">	1、UniFlash简介</a><br>
<a href="#2%E3%80%81%E8%BD%AF%E4%BB%B6%E8%8E%B7%E5%8F%96">	2、软件获取</a><br>
<a href="#3%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">	3、软件安装</a><br>
<a href="#4%E3%80%81%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE">	4、软件配置</a><br>
<a href="#%E5%85%AD%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E7%A8%8B%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%89%A7%E8%A1%8C">六、第一个例程的修改与执行</a><br>
<a href="#1%E3%80%81%E4%BE%8B%E7%A8%8B%E5%AF%BC%E5%85%A5">	1、例程导入</a><br>
<a href="#2%E3%80%81%E4%BE%8B%E7%A8%8B%E4%BF%AE%E6%94%B9%E5%92%8C%E7%83%A7%E5%BD%95">	2、例程修改和烧录</a><br>
<a href="#1.%E6%9F%A5%E7%9C%8B%E5%8E%9F%E7%90%86%E5%9B%BE">		1.查看原理图</a><br>
<a href="#2.%E4%BF%AE%E6%94%B9%E8%8A%AF%E7%89%87%E5%9E%8B%E5%8F%B7">		2.修改芯片型号</a><br>
<a href="#3.%E4%BF%AE%E6%94%B9%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE">		3.修改时钟配置</a><br>
[		4. 修改GPIO配置](#4. 修改GPIO配置)<br>
[		5. 尝试编译](#5. 尝试编译)<br>
<a href="#6.%E4%BF%AE%E6%94%B9%E4%B8%BB%E5%87%BD%E6%95%B0">		6.修改主函数</a><br>
[		7. 配置生成HEX文件](#7. 配置生成HEX文件)<br>
[		8. 编译生成HEX文件](#8. 编译生成HEX文件)<br>
[		9. 在UniFlash中选择芯片型号](#9. 在UniFlash中选择芯片型号)<br>
<a href="#10.%E5%B0%86HEX%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5Uniflash%E4%B8%AD">		10.将HEX文件导入Uniflash中</a><br>
[		11. 使开发板进入烧录状态](#11. 使开发板进入烧录状态)<br>
<a href="#12.%E4%B8%8B%E8%BD%BDHEX%E6%96%87%E4%BB%B6">		12.下载HEX文件</a><br>
[		13. 观察现象](#13. 观察现象)<br>
<a href="#%E6%80%BB%E7%BB%93">总结</a><br>
<a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></p>
<hr>
<h1 id="前言">前言</h1>
<p>对于一款新开发板的上手来说，搭建开发环境是首要步骤。本文的内容是教大家如何基于 CCS 软件和 UniFlash 工具来完成 MSPM0G3507 开发环境的搭建。</p>
<h1 id="一-开发环境选择">一、开发环境选择</h1>
<p>TI 官方为开发者提供了多样化的开发工具链选择，其官方开发指南中详细列举了相关工具。</p>
<figure data-type="image" tabindex="1"><img src="https://temry.github.io/post-images/1764312673561.png" alt="" loading="lazy"></figure>
<p>相较于 Keil 和 IAR ，CCS 不仅提供了专为 TI MSPM0 系列微控制器优化的开发环境，包括 SysConfig 工具简化外设配置和代码生成，还拥有类似 VSCode 的美观编程界面风格，这使得 CCS 在提高开发效率和代码质量的同时，也为开发者提供了更舒适的视觉体验，基于上述原因，笔者选择 CCS 作为代码编辑、编译工具。<br>
       相较于 J-Link 和 XDS110 ，UniFlash 提供了一种专为TI微控制器设计的烧录解决方案，它支持通过串口进行编程，无需额外的硬件仿真器，简化了烧录流程。此外，UniFlash 拥有用户友好的操作界面，使得烧录过程直观易懂，这不仅提高了烧录的便捷性，也为开发者带来了更流畅的体验。基于这些优势，笔者选择了 UniFlash 作为烧录工具。</p>
<h1 id="二-开发板选择">二、开发板选择</h1>
<p>作者所使用的开发板是一块价值约20元的最小系统板，购自淘宝，链接如下：</p>
<p><a href="https://item.taobao.com/item.htm?id=946196615571&amp;skuId=5855714673149&amp;spm=tbpc.boughtlist.suborder_itempic.d946196615571.72962e8dVKav4R" title="WeAct MSPM0G3507SRHBR MSPM0G3507 核心板 开发板 带USB转串口">WeAct MSPM0G3507SRHBR MSPM0G3507 核心板 开发板 带USB转串口</a></p>
<h1 id="三-mspm0_sdk下载及配置">三、MSPM0_SDK下载及配置</h1>
<h2 id="1-mspm0_sdk简介">1、MSPM0_SDK简介</h2>
<p>MSPM0 SDK 是德州仪器为 MSPM0 系列微控制器开发的一套全面的软件开发工具包，它整合了驱动程序库、中间件、示例代码、详细文档和教程，以及与 Code Composer Studio 集成的代码生成工具，旨在简化开发流程、提高开发效率，并帮助开发者快速上手，实现从硬件抽象到应用逻辑的高效开发。</p>
<h2 id="2-软件获取">2、软件获取</h2>
<p>可以直接从 TI 官网上直接下载到 MSPM0_SDK 。下载地址如下：</p>
<p><a href="https://www.ti.com.cn/tool/cn/MSPM0-SDK?keyMatch=mspm0&amp;tisearch=universal_search&amp;usecase=partmatches#downloads" title="MSPM0-SDK 软件开发套件 (SDK) | 德州仪器 TI.com.cn">MSPM0-SDK 软件开发套件 (SDK) | 德州仪器 TI.com.cn</a></p>
<p>在下载过程中，需要注意以下两点：</p>
<ol>
<li>下载过程中需要用到 TI 账号登录，没有的话需要注册一个。</li>
<li>下载过程会要求填写个人信息，应用场景需选择“Civil(民用)”。</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://temry.github.io/post-images/1764312684444.png" alt="" loading="lazy"></figure>
<h2 id="3-软件安装">3、软件安装</h2>
<p>安装过程很简单，没有多余选项，跟着安装程序走就行，故笔者在此不作讲解。值得注意的是，我们仔细观察安装过程中所执行的命令的话不难发现，MSPM0_SDK 的安装过程实际上是一个先创建目录、再解压文件的过程。</p>
<figure data-type="image" tabindex="3"><img src="https://temry.github.io/post-images/1764312692119.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:center">MSPM0_SDK安装过程中在不断地创建文件夹</th>
</tr>
</thead>
</table>
<figure data-type="image" tabindex="4"><img src="https://temry.github.io/post-images/1764312700216.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:center">MSPM0_SDK安装过程中在不断地解压文件</th>
</tr>
</thead>
</table>
<h2 id="4-软件配置">4、软件配置</h2>
<p>MSPM0_SDK 安装完成后需要重点关注安装路径下生成的文件夹结构。安装完成后，目录中通常会包含以下文件夹：</p>
<ul>
<li><strong>docs：</strong> 包含 SDK 的所有文档</li>
<li><strong>examples：</strong> 包含示例代码，帮助快速上手开发</li>
<li><strong>kernel：</strong> 实时操作系统（RTOS）和非实时操作系统（nortos）的构建文件</li>
<li><strong>source：</strong> 包含 TI 和第三方库的所有源代码</li>
<li><strong>tools：</strong> 包含与 SDK 相关的所有工具，例如 SysConfig 支持文件、BSL GUI 和计量 GUI</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://temry.github.io/post-images/1764312710760.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:center">MSPM0-SDK 安装目录结构</th>
</tr>
</thead>
</table>
<h1 id="四-ccs下载及配置">四、CCS下载及配置</h1>
<h2 id="1-ccs简介">1、CCS简介</h2>
<p>Code Composer Studio（CCS）是TI官方开发的一款集成开发环境，专门用于 TI 的数字信号处理器、微控制器和应用处理器的开发。CCS提供了一整套工具，包括编译器、源代码编辑器、项目构建环境、调试器、描述器、仿真器等，以支持嵌入式应用的开发和调试。</p>
<h2 id="2-软件获取-2">2、软件获取</h2>
<p>可以直接从 TI 官网上直接下载到 CCS 。下载地址如下：</p>
<p><a href="https://www.ti.com.cn/tool/cn/CCSTUDIO?keyMatch=ccs&amp;tisearch=universal_search&amp;usecase=partmatches#downloads" title="CCSTUDIO IDE、配置、编译器或调试器 | 德州仪器 TI.com.cn">CCSTUDIO IDE、配置、编译器或调试器 | 德州仪器 TI.com.cn</a></p>
<p>在下载过程中，必须要注意的是：</p>
<ol>
<li>必须将所下载的安装包解压到纯英文路径下，否则运行安装程序会报错。</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://temry.github.io/post-images/1764312718614.png" alt="" loading="lazy"></figure>
<h2 id="3-软件安装-2">3、软件安装</h2>
<p>CCS的安装过程也很简单，跟着安装程序走就行，只有在选择需要被CCS支持的芯片型号时需稍加注意：<br>
       CCS支持多种TI处理器，包括但不限于 TMS320C6000、TMS320C5000、TMS320C2800、TMS470、TMS570、ARM 系列和 MSP430 等。安装时可根据实际需求勾选目标芯片型号。若需全面学习，可勾选所有选项；建议根据项目或学习重点选择特定型号以节省资源。需要注意的是，为了开发 MSPM0G3507 目标芯片，图中红色框选中的选项必须勾选。</p>
<figure data-type="image" tabindex="7"><img src="https://temry.github.io/post-images/1764312726428.png" alt="" loading="lazy"></figure>
<h2 id="4-软件配置-2">4、软件配置</h2>
<p>CCS软件安装完成后无需额外配置。</p>
<h1 id="五-uniflash下载及配置">五、UniFlash下载及配置</h1>
<h2 id="1-uniflash简介">1、UniFlash简介</h2>
<p>UniFlash 是 TI 官方提供的一款软件工具，它用于对 TI 微控制器和无线连接器件上的片上闪存以及 TI 处理器的板载闪存进行编程。UniFlash 提供了图形用户界面（GUI）和命令行界面，支持在 TI 开发人员专区从云中运行，也可以下载并在 Windows、Linux 和 macOS 计算机上使用。</p>
<h2 id="2-软件获取-3">2、软件获取</h2>
<p>可以直接从 TI 官网上直接下载到 Uniflash 。下载地址如下：</p>
<p><a href="https://www.ti.com.cn/tool/cn/UNIFLASH?keyMatch=UNIFLASH&amp;tisearch=universal_search&amp;usecase=software#downloads" title="UNIFLASH 软件编程工具 | 德州仪器 TI.com.cn">UNIFLASH 软件编程工具 | 德州仪器 TI.com.cn</a></p>
<h2 id="3-软件安装-3">3、软件安装</h2>
<p>安装过程很简单，没有多余选项，跟着安装程序走就行，故笔者在此不作讲解。</p>
<h2 id="4-软件配置-3">4、软件配置</h2>
<p>CCS 软件安装完成后通常无需额外配置。</p>
<h1 id="六-第一个例程的修改与执行">六、第一个例程的修改与执行</h1>
<h2 id="1-例程导入">1、例程导入</h2>
<ol>
<li>打开CCS软件、选择以 &quot; Import Project(s) &quot; 方式来新建工程。</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://temry.github.io/post-images/1764312737090.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>将 MSPM0_SDK 安装目录中例程 &quot; gpio_toggle_output &quot; 下的 &quot; ticlang &quot; 文件夹导入到 CCS 中。</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://temry.github.io/post-images/1764312745023.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>点击 &quot; Finish &quot; 以完成选择。</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://temry.github.io/post-images/1764312752924.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>此时可以看到例程已经被导入，左侧为资源管理器面板，右侧默认展示的是工程内Sysconfig配置文件的详细内容。</li>
</ol>
<figure data-type="image" tabindex="11"><img src="https://temry.github.io/post-images/1764312760991.png" alt="" loading="lazy"></figure>
<ol start="5">
<li>此时选择 &quot; Build Project &quot; 编译工程。</li>
</ol>
<figure data-type="image" tabindex="12"><img src="https://temry.github.io/post-images/1764312770698.png" alt="" loading="lazy"></figure>
<ol start="6">
<li>当右下角显示 &quot; Build Finished &quot; 时，表明编译已成功完成，同时验证了 CCS 的安装过程没有出错。</li>
</ol>
<figure data-type="image" tabindex="13"><img src="https://temry.github.io/post-images/1764312778732.png" alt="" loading="lazy"></figure>
<h2 id="2-例程修改和烧录">2、例程修改和烧录</h2>
<p>MSPM0 SDK 提供的例程是专为 LP-MSPM0G3507 开发板设计的。若要将这些例程适配到我们自己的开发板上，则需要进行一些修改，特别是时钟和外设引脚的配置。具体的修改步骤如下所示：</p>
<h3 id="1查看原理图">1.查看原理图</h3>
<p>我们必须清楚开发板上各个外设所连接的 GPIO 引脚号，才能知道如何对 SDK 提供的例程进行修改。通过例程名中的 &quot; toggle（切换）&quot; 一词，我们可以明确该例程实现的功能为 GPIO 闪烁。因此，我们需要特别关注的是连接到开发板上 LED 灯的引脚。在开发板的原理图中，我们可以清楚地看到，该开发板并未连接外部时钟电路，LED 灯的正极经一 5.1kΩ 电阻连接到电源，而负极则直接连接到了 PA0 引脚。</p>
<figure data-type="image" tabindex="14"><img src="https://temry.github.io/post-images/1764312832223.png" alt="" loading="lazy"></figure>
<h3 id="2修改芯片型号">2.修改芯片型号</h3>
<p>我们自己购买的开发板有时会与 SDK 例程适配的开发板型号不同。为了使例程能够在我们的开发板上正常工作，我们必须将例程中的开发板型号修改为我们实际购买的开发板型号。通常，开发板的型号可以在其商品主页上查询到。例如，笔者这里使用的是 MSPM0G3507SRHBR 型号的开发板，修改操作如下：</p>
<figure data-type="image" tabindex="15"><img src="https://temry.github.io/post-images/1764312840763.png" alt="" loading="lazy"></figure>
<h3 id="3修改时钟配置">3.修改时钟配置</h3>
<p>对于任何一款 MCU 来说，时钟系统都是非常重要的，时钟相当于芯片的心脏。MCU 的时钟来源大致可以分为两种：内部时钟源和外部时钟源。也就是说，时钟可能来源于内部振荡器，也可能来源于外部晶振。在查看原理图时，我们已经确认笔者所使用的开发板没有接入外部时钟。因此，我们必须查看例程中的配置，确保芯片的所有工作电路的时钟信号均来自内部时钟源。如果例程中使用了外部时钟的外设，则需要将这些外设的时钟源切换到内部时钟源上。通过观察时钟树，我们可以发现除了 CAN 外设之外，其他外设都已连接到内部时钟上。在本例程中，我们并不需要使用 CAN 总线这一外设，因此无需对时钟配置进行修改。</p>
<figure data-type="image" tabindex="16"><img src="https://temry.github.io/post-images/1764312849439.png" alt="" loading="lazy"></figure>
<h3 id="4-修改gpio配置">4. 修改GPIO配置</h3>
<p>正如前面提到的，我们需要根据所购买开发板的原理图来修改例程，从而确保芯片的 GPIO 口能够正确控制所连接的外设。具体的修改过程如下：首先，删除多余的 GPIO 口配置（根据原理图，我们的开发板上只有 1 个 LED 灯，因此不需要多余的 GPIO 配置），然后，将 GPIO 口配置改为 PA0（根据原理图，开发板上的 LED 灯连接到 PA0 引脚）。</p>
<figure data-type="image" tabindex="17"><img src="https://temry.github.io/post-images/1764312856317.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:center">删除多余的GPIO口配置</th>
</tr>
</thead>
</table>
<figure data-type="image" tabindex="18"><img src="https://temry.github.io/post-images/1764312864251.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:center">将GPIO口配置改为PA0</th>
</tr>
</thead>
</table>
<h3 id="5-尝试编译">5. 尝试编译</h3>
<p>在修改完开发板的配置文件后，我们可以尝试进行编译，看看会出现什么结果。然而，我们会发现编译仍然无法通过。这是因为我们尚未修改主程序文件。换句话说，虽然我们已经修改了配置文件，但还需要在主程序中对所调用的函数进行相应的修改。</p>
<figure data-type="image" tabindex="19"><img src="https://temry.github.io/post-images/1764312874749.png" alt="" loading="lazy"></figure>
<h3 id="6修改主函数">6.修改主函数</h3>
<p>正如前面所述，我们已经删除了 3 个 GPIO 口的配置。因此，在主程序中，我们也需要相应地删除与这 3 个 GPIO 口相关的所有操作。下图是修改后的主函数：</p>
<figure data-type="image" tabindex="20"><img src="https://temry.github.io/post-images/1764312883853.png" alt="" loading="lazy"></figure>
<h3 id="7-配置生成hex文件">7. 配置生成HEX文件</h3>
<p>在修改好主程序之后，读者可以尝试重新编译项目。如果之前的修改正确无误，编译应该会顺利通过。然而，这还不够。我们最终需要的是能够通过 UniFlash 下载到开发板中的 HEX 文件。为了生成 HEX 文件，我们需要对 CCS 的配置进行修改，因为 CCS 默认情况下是不会生成 HEX 文件的，我们必须手动设置它以生成 HEX 文件。并且我们还需要配置最后生成的 HEX 文件在向 MCU 中烧录时按八位对齐，否则会在烧录时出现报错。</p>
<figure data-type="image" tabindex="21"><img src="https://temry.github.io/post-images/1764312892573.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:center">由于没有设置按8位对齐烧录而在烧录时出现的错误</th>
</tr>
</thead>
</table>
<figure data-type="image" tabindex="22"><img src="https://temry.github.io/post-images/1764312899999.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://temry.github.io/post-images/1764312908531.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="24"><img src="https://temry.github.io/post-images/1764312925418.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="25"><img src="https://temry.github.io/post-images/1764312932797.png" alt="" loading="lazy"></figure>
<h3 id="8-编译生成hex文件">8. 编译生成HEX文件</h3>
<p>此时可以重新编译项目以生成 HEX 文件，并在文件管理器中查看生成的 HEX 文件所在的位置。</p>
<figure data-type="image" tabindex="26"><img src="https://temry.github.io/post-images/1764312941188.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://temry.github.io/post-images/1764312948584.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:center">在资源管理器中查看HEX文件所在位置</th>
</tr>
</thead>
</table>
<h3 id="9-在uniflash中选择芯片型号">9. 在UniFlash中选择芯片型号</h3>
<p>到目前为止，我们在 CCS 中需要完成的所有操作都已经完成了。接下来，烧录操作需要在 UniFlash 工具中进行。首先，我们需要在 UniFlash 中选择目标芯片的型号。</p>
<figure data-type="image" tabindex="28"><img src="https://temry.github.io/post-images/1764312957128.png" alt="" loading="lazy"></figure>
<h3 id="10将hex文件导入uniflash中">10.将HEX文件导入Uniflash中</h3>
<p>在选择完开发板型号后，我们需要将 HEX 文件导入 UniFlash 中，并选择与开发板连接的串口（与开发板相连的串口可以在设备管理器中查询到）。</p>
<figure data-type="image" tabindex="29"><img src="https://temry.github.io/post-images/1764312965274.png" alt="" loading="lazy"></figure>
<h3 id="11-使开发板进入烧录状态">11. 使开发板进入烧录状态</h3>
<p>使开发板进入烧录状态的步骤如下：首先按住板子上的 BSL 键，接着按住板子上的 RST 键，然后松开板子上的 RST 键，最后松开板子上的BSL键。作者试了一下，这四步操作之间的时间间隔是比较宽松的，也就是说，每两步操作之间，无论是隔较短的时间还是较长的时间，通常都不会导致下载失败（当然，如果操作间隔超过十几秒则除外，因为进入烧录模式后超过十秒会进入低功耗模式）。</p>
<figure data-type="image" tabindex="30"><img src="https://temry.github.io/post-images/1764312973135.png" alt="" loading="lazy"></figure>
<h3 id="12下载hex文件">12.下载HEX文件</h3>
<p>直接点击 &quot; Load Image &quot; 即可下载。下载成功后会出现 &quot; Programming speed:  X.XXXXkByte/s &quot; 字样。</p>
<figure data-type="image" tabindex="31"><img src="https://temry.github.io/post-images/1764312981195.png" alt="" loading="lazy"></figure>
<h3 id="13-观察现象">13. 观察现象</h3>
<p>正常现象为蓝色LED灯不断闪烁。</p>
<h1 id="总结">总结</h1>
<p>本文介绍了基于 CCS 和 UniFlash 搭建 MSPM0G3507 开发环境及修改烧录第一个例程的过程。首先，选择了 CCS 作为开发工具，因其为 MSPM0 系列提供了优化的开发环境和美观界面；UniFlash则作为烧录工具，支持串口编程，简化烧录流程。开发板选用的是约 20 元的 WeAct MSPM0G3507SRHBR 核心板。接着，从 TI 官网下载并安装了 MSPM0 SDK 、CCS 和 UniFlash ，这些工具为开发提供了必要的支持。在修改例程时，根据开发板原理图对 GPIO 配置和主程序进行了调整，确保 LED 灯能通过 PA0 引脚控制，并配置 CCS 生成按 8 位对齐的 HEX 文件。最后，通过 UniFlash 选择芯片型号、导入 HEX 文件并选择串口，完成烧录，观察到 LED 灯闪烁，表明烧录成功。</p>
<h1 id="参考资料">参考资料</h1>
<p><a href="https://blog.csdn.net/weixin_41784968/article/details/147356570?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-147356570-blog-140305748.235%5Ev43%5Epc_blog_bottom_relevance_base8&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" title="UniFlash以串口方式烧录MSPM0G3507(无需仿真器)_uniflash烧录程序步骤-CSDN博客">UniFlash以串口方式烧录MSPM0G3507(无需仿真器)_uniflash烧录程序步骤-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_41082557/article/details/117092952?ops_request_misc=%257B%2522request%255Fid%2522%253A%25222ba65e60e89048663f154d6cb73a3d34%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=2ba65e60e89048663f154d6cb73a3d34&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-117092952-null-null.142%5Ev102%5Epc_search_result_base2&amp;utm_term=ccs%20%E7%94%9F%E6%88%90hex%E6%96%87%E4%BB%B6&amp;spm=1018.2226.3001.4187" title="CCS生成hex方法_ccs生成hex文件-CSDN博客">CCS生成hex方法_ccs生成hex文件-CSDN博客</a></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E4%B8%80-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%80%89%E6%8B%A9">一、开发环境选择</a></li>
<li><a href="#%E4%BA%8C-%E5%BC%80%E5%8F%91%E6%9D%BF%E9%80%89%E6%8B%A9">二、开发板选择</a></li>
<li><a href="#%E4%B8%89-mspm0_sdk%E4%B8%8B%E8%BD%BD%E5%8F%8A%E9%85%8D%E7%BD%AE">三、MSPM0_SDK下载及配置</a>
<ul>
<li><a href="#1-mspm0_sdk%E7%AE%80%E4%BB%8B">1、MSPM0_SDK简介</a></li>
<li><a href="#2-%E8%BD%AF%E4%BB%B6%E8%8E%B7%E5%8F%96">2、软件获取</a></li>
<li><a href="#3-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">3、软件安装</a></li>
<li><a href="#4-%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE">4、软件配置</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-ccs%E4%B8%8B%E8%BD%BD%E5%8F%8A%E9%85%8D%E7%BD%AE">四、CCS下载及配置</a>
<ul>
<li><a href="#1-ccs%E7%AE%80%E4%BB%8B">1、CCS简介</a></li>
<li><a href="#2-%E8%BD%AF%E4%BB%B6%E8%8E%B7%E5%8F%96-2">2、软件获取</a></li>
<li><a href="#3-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-2">3、软件安装</a></li>
<li><a href="#4-%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE-2">4、软件配置</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-uniflash%E4%B8%8B%E8%BD%BD%E5%8F%8A%E9%85%8D%E7%BD%AE">五、UniFlash下载及配置</a>
<ul>
<li><a href="#1-uniflash%E7%AE%80%E4%BB%8B">1、UniFlash简介</a></li>
<li><a href="#2-%E8%BD%AF%E4%BB%B6%E8%8E%B7%E5%8F%96-3">2、软件获取</a></li>
<li><a href="#3-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-3">3、软件安装</a></li>
<li><a href="#4-%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE-3">4、软件配置</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E7%A8%8B%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%89%A7%E8%A1%8C">六、第一个例程的修改与执行</a>
<ul>
<li><a href="#1-%E4%BE%8B%E7%A8%8B%E5%AF%BC%E5%85%A5">1、例程导入</a></li>
<li><a href="#2-%E4%BE%8B%E7%A8%8B%E4%BF%AE%E6%94%B9%E5%92%8C%E7%83%A7%E5%BD%95">2、例程修改和烧录</a>
<ul>
<li><a href="#1%E6%9F%A5%E7%9C%8B%E5%8E%9F%E7%90%86%E5%9B%BE">1.查看原理图</a></li>
<li><a href="#2%E4%BF%AE%E6%94%B9%E8%8A%AF%E7%89%87%E5%9E%8B%E5%8F%B7">2.修改芯片型号</a></li>
<li><a href="#3%E4%BF%AE%E6%94%B9%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE">3.修改时钟配置</a></li>
<li><a href="#4-%E4%BF%AE%E6%94%B9gpio%E9%85%8D%E7%BD%AE">4. 修改GPIO配置</a></li>
<li><a href="#5-%E5%B0%9D%E8%AF%95%E7%BC%96%E8%AF%91">5. 尝试编译</a></li>
<li><a href="#6%E4%BF%AE%E6%94%B9%E4%B8%BB%E5%87%BD%E6%95%B0">6.修改主函数</a></li>
<li><a href="#7-%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90hex%E6%96%87%E4%BB%B6">7. 配置生成HEX文件</a></li>
<li><a href="#8-%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90hex%E6%96%87%E4%BB%B6">8. 编译生成HEX文件</a></li>
<li><a href="#9-%E5%9C%A8uniflash%E4%B8%AD%E9%80%89%E6%8B%A9%E8%8A%AF%E7%89%87%E5%9E%8B%E5%8F%B7">9. 在UniFlash中选择芯片型号</a></li>
<li><a href="#10%E5%B0%86hex%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5uniflash%E4%B8%AD">10.将HEX文件导入Uniflash中</a></li>
<li><a href="#11-%E4%BD%BF%E5%BC%80%E5%8F%91%E6%9D%BF%E8%BF%9B%E5%85%A5%E7%83%A7%E5%BD%95%E7%8A%B6%E6%80%81">11. 使开发板进入烧录状态</a></li>
<li><a href="#12%E4%B8%8B%E8%BD%BDhex%E6%96%87%E4%BB%B6">12.下载HEX文件</a></li>
<li><a href="#13-%E8%A7%82%E5%AF%9F%E7%8E%B0%E8%B1%A1">13. 观察现象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://temry.github.io/post/mspm0g3507-xue-xi-bi-ji-0xue-xi-kai-shi-qian-de-zi-liao-shou-ji/">
              <h3 class="post-title">
                【MSPM0G3507】学习笔记(0)：学习开始前的资料收集
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://temry.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
